[{"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\index.tsx":"1","C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\reportWebVitals.ts":"2","C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\App.tsx":"3","C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\Devices.tsx":"4","C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\DeviceRender.tsx":"5","C:\\Users\\Marco\\git\\gateway-client-web\\src\\index.tsx":"6","C:\\Users\\Marco\\git\\gateway-client-web\\src\\reportWebVitals.ts":"7","C:\\Users\\Marco\\git\\gateway-client-web\\src\\OpenStuder\\OpenStuder.ts":"8","C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleSimple\\AppSampleSimple.tsx":"9","C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\AppSampleHard.tsx":"10","C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\Devices.tsx":"11","C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\DeviceMessageRender.tsx":"12"},{"size":500,"mtime":1612174867139,"results":"13","hashOfConfig":"14"},{"size":425,"mtime":499162500000,"results":"15","hashOfConfig":"14"},{"size":6172,"mtime":1613056576616,"results":"16","hashOfConfig":"14"},{"size":1490,"mtime":1612519156791,"results":"17","hashOfConfig":"14"},{"size":1605,"mtime":1613057208321,"results":"18","hashOfConfig":"14"},{"size":521,"mtime":1616749982685,"results":"19","hashOfConfig":"20"},{"size":425,"mtime":499162500000,"results":"21","hashOfConfig":"20"},{"size":61378,"mtime":1616749586378,"results":"22","hashOfConfig":"20"},{"size":5347,"mtime":1616407070761,"results":"23","hashOfConfig":"20"},{"size":8262,"mtime":1617026149778,"results":"24","hashOfConfig":"20"},{"size":7849,"mtime":1617026105438,"results":"25","hashOfConfig":"20"},{"size":2070,"mtime":1617003968968,"results":"26","hashOfConfig":"20"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"16hdhh2",{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"41"},"o8738k",{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"41"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"41"},"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\index.tsx",[],["56","57"],"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\reportWebVitals.ts",[],"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\App.tsx",["58"],"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\Devices.tsx",[],"C:\\Users\\Marco\\WebstormProjects\\studernext-simpleclient\\src\\DeviceRender.tsx",["59","60","61"],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\index.tsx",["62","63"],"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport AppSampleMedium from './AppSampleMedium/AppSampleMedium';\nimport AppSampleSimple from \"./AppSampleSimple/AppSampleSimple\";\nimport AppSampleHard from \"./AppSampleHard/AppSampleHard\";\nimport reportWebVitals from './reportWebVitals';\n\n\n\n//Modify this function to change the example application\nReactDOM.render(\n  <React.StrictMode>\n    <AppSampleHard />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nreportWebVitals();\n",["64","65"],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\reportWebVitals.ts",[],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\OpenStuder\\OpenStuder.ts",["66","67"],"/**\r\n * Status of operations on the OpenStuder gateway.\r\n *\r\n * -SIStatus.SUCCESS: Operation was successfully completed.\r\n * -SIStatus.IN_PROGRESS: Operation is already in progress or another operation is occupying the resource.\r\n * -SIStatus.ERROR: General (unspecified) error.\r\n * -SIStatus.NO_PROPERTY: The property does not exist or the user's access level does not allow to access the property.\r\n * -SIStatus.NO_DEVICE: The device does not exist.\r\n * -SIStatus.NO_DEVICE_ACCESS: The device access instance does not exist.\r\n * -SIStatus.TIMEOUT: A timeout occurred when waiting for the completion of the operation.\r\n * -SIStatus.INVALID_VALUE: A invalid value was passed.\r\n */\r\nexport enum SIStatus{\r\n    SUCCESS = 0,\r\n    IN_PROGRESS = 1,\r\n    ERROR = -1,\r\n    NO_PROPERTY = -2,\r\n    NO_DEVICE = -3,\r\n    NO_DEVICE_ACCESS = -4,\r\n    TIMEOUT = -5,\r\n    INVALID_VALUE = -6,\r\n}\r\n\r\nfunction SIStatusFromString(str:string):SIStatus{\r\n    switch(str){\r\n        case \"Success\":\r\n            return SIStatus.SUCCESS;\r\n        case \"InProgress\":\r\n            return SIStatus.IN_PROGRESS;\r\n        case \"Error\":\r\n            return SIStatus.ERROR;\r\n        case \"NoProperty\":\r\n            return SIStatus.NO_PROPERTY;\r\n        case \"NoDevice\":\r\n            return SIStatus.NO_DEVICE;\r\n        case \"NoDeviceAccess\":\r\n            return SIStatus.NO_DEVICE_ACCESS;\r\n        case \"Timeout\":\r\n            return SIStatus.TIMEOUT;\r\n        case \"InvalidValue\":\r\n            return SIStatus.INVALID_VALUE;\r\n        default:\r\n            return SIStatus.ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * State of the connection to the OpenStuder gateway.\r\n *\r\n * -SIConnectionState.DISCONNECTED: The client is not connected.\r\n * -SIConnectionState.CONNECTING: The client is establishing the WebSocket connection to the gateway.\r\n * -SIConnectionState.AUTHORIZING: The WebSocket connection to the gateway has been established\r\n * and the client is authorizing.\r\n * -SIConnectionState.CONNECTED: The WebSocket connection is established and the client is authorized, ready to use.\r\n */\r\nexport enum SIConnectionState{\r\n    DISCONNECTED,\r\n    CONNECTING,\r\n    AUTHORIZING,\r\n    CONNECTED,\r\n}\r\n\r\n/**\r\n * Level of access granted to a client from the OpenStuder gateway.\r\n *\r\n * -NONE: No access at all.\r\n * -BASIC: Basic access to device information properties (configuration excluded).\r\n * -INSTALLER: Basic access + additional access to most common configuration properties.\r\n * -EXPERT: Installer + additional advanced configuration properties.\r\n * -QUALIFIED_SERVICE_PERSONNEL: Expert and all configuration and service properties\r\n * only for qualified service personnel.\r\n */\r\nexport enum SIAccessLevel{\r\n    NONE,\r\n    BASIC,\r\n    INSTALLER,\r\n    EXPERT,\r\n    QUALIFIED_SERVICE_PERSONNEL\r\n}\r\n\r\nfunction SIAccessLevelFromString(str:string):SIAccessLevel{\r\n    switch(str){\r\n        case(\"None\"):\r\n            return SIAccessLevel.NONE;\r\n        case(\"Basic\"):\r\n            return SIAccessLevel.BASIC;\r\n        case(\"Installer\"):\r\n            return SIAccessLevel.INSTALLER;\r\n        case(\"Expert\"):\r\n            return SIAccessLevel.EXPERT;\r\n        case(\"QSP\"):\r\n            return SIAccessLevel.QUALIFIED_SERVICE_PERSONNEL;\r\n        default:\r\n            return SIAccessLevel.NONE;\r\n    }\r\n}\r\n\r\n/**\r\n * Flags to control the format of the \"DESCRIBE\" functionality.\r\n *\r\n * -SIDescriptionFlags.NONE: No description flags.\r\n * -SIDescriptionFlags.INCLUDE_ACCESS_INFORMATION: Includes device access instances information.\r\n * -SIDescriptionFlags.INCLUDE_DEVICE_INFORMATION: Include device information.\r\n * -SIDescriptionFlags.INCLUDE_DRIVER_INFORMATION: Include device property information.\r\n * -SIDescriptionFlags.INCLUDE_DRIVER_INFORMATION: Include device access driver information.\r\n */\r\nexport enum SIDescriptionFlags{\r\n    INCLUDE_ACCESS_INFORMATION,\r\n    INCLUDE_PROPERTY_INFORMATION,\r\n    INCLUDE_DEVICE_INFORMATION,\r\n    INCLUDE_DRIVER_INFORMATION ,\r\n}\r\n\r\n/**\r\n * Flags to control write property operation.\r\n *\r\n * -SIWriteFlags.NONE: No write flags.\r\n * -SIWriteFlags.PERMANENT: Write the change to the persistent storage, eg the change lasts reboots.\r\n */\r\nexport enum SIWriteFlags{\r\n    NONE=0,\r\n    PERMANENT=1,\r\n}\r\n\r\n/**\r\n * A received frame will be treated as this type to separate his information\r\n *\r\n * -command : The first line of the frame which indicates the actual information\r\n * -body : Contain information which are better to treat with a JSON format\r\n * -headers : Contain basic information of the frame\r\n */\r\ntype DecodedFrame={\r\n    command:string,\r\n    body:string,\r\n    headers:Map<string,string>\r\n}\r\n\r\n/**\r\n * Information of received messages will be transferred between class with this type\r\n */\r\ntype SIInformation={\r\n    body?:string,\r\n    status?:string,\r\n    deviceCount?:string,\r\n    id?:string,\r\n    value?:string,\r\n    accessId?:string,\r\n    messageId?:string,\r\n    deviceId?:string,\r\n    message?:string,\r\n    accessLevel?:string,\r\n    count?:string,\r\n    timestamp?:string,\r\n    gatewayVersion?:string,\r\n}\r\n\r\n/**\r\n * The SIDPropertyReadResult class represents the status of a property read result.\r\n */\r\nexport type SIPropertyReadResult={\r\n    status:SIStatus,\r\n    id:string,\r\n    value?:any,\r\n}\r\n\r\n/**\r\n * The SIDSubscriptionsResult class represents the status of a property subscription/unsubscription.\r\n */\r\nexport type SISubscriptionsResult={\r\n    status:SIStatus,\r\n    id:string,\r\n}\r\n\r\n/**\r\n * The SIDeviceMessage class represents a message a device connected to the OpenStuder gateway has broadcast.\r\n */\r\nexport type SIDeviceMessage={\r\n    timestamp:string,\r\n    accessId:string,\r\n    deviceId:string,\r\n    messageId:string,\r\n    message:string\r\n}\r\n\r\n/**\r\n * @class SIProtocolError\r\n * Class for reporting all OpenStuder protocol errors.\r\n */\r\nclass SIProtocolError{\r\n    static raise(error:string){\r\n        throw new Error(error);\r\n    }\r\n}\r\n\r\n/**\r\n * @class SIAbstractGatewayClient\r\n * Abstract gateway to gives mandatory function to treat the frame with the defined websocket protocol\r\n */\r\nclass SIAbstractGatewayClient {\r\n    /**\r\n     * Function used to separate the information into a \"DecodedFrame\" instance\r\n     * @param frame FSrame to be decoded\r\n     */\r\n    protected static decodeFrame(frame:string):DecodedFrame{\r\n        let command:string=\"INVALID\";\r\n        let headers:Map<string,string>=new Map<string, string>();\r\n\r\n        let lines:string[]=frame.split(\"\\n\");\r\n        if(lines.length>1){\r\n            command=lines[0];\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"Invalid frame\");\r\n        }\r\n\r\n        let line=1;\r\n        while (line<lines.length){\r\n            let components = lines[line].split(\":\");\r\n            //General case\r\n            if (components.length===2){\r\n                headers.set(components[0],components[1]);\r\n            }\r\n            //if our components has a timestamp, it will have several ':'\r\n            if(components.length>2){\r\n                let value=\"\";\r\n                for(let i=1;i<components.length;i++){\r\n                    value+=\":\"+components[i];\r\n                }\r\n                headers.set(components[0],value);\r\n            }\r\n            line +=1;\r\n            //We don't want to treat the body here, we need to break before\r\n            if(lines[line]===\"\"){\r\n                line +=1;\r\n                break;\r\n            }\r\n        }\r\n        let body = lines[line];\r\n        line+=1;\r\n        while(line<lines.length){\r\n            if(lines[line]!==\"\") {\r\n                body += \"\\n\" + lines[line];\r\n            }\r\n            line++;\r\n        }\r\n\r\n        return {body: body, headers: headers, command: command};\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to the gateway with the different credentials\r\n     * @param user Name of the user\r\n     * @param password Password for the user\r\n     */\r\n    protected static encodeAuthorizeFrame(user?:string, password?:string):string{\r\n        if(user===undefined || password === undefined) {\r\n            return \"AUTHORIZE\\nuser:\" + user + \"\\npassword:\" + password + \"\\nprotocol_version:1\\n\\n\";\r\n        }\r\n        else{\r\n            return 'AUTHORIZE\\nprotocol_version:1\\n\\n';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decode an authorize frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodeAuthorizedFrame(frame:string):SIInformation{\r\n        let decodedFrame:DecodedFrame = this.decodeFrame(frame);\r\n        let retVal:SIInformation= {\r\n            accessLevel:undefined,\r\n            gatewayVersion:undefined,\r\n        };\r\n\r\n        if(decodedFrame.command===\"AUTHORIZED\" && decodedFrame.headers.has(\"access_level\") &&\r\n            decodedFrame.headers.has(\"protocol_version\")){\r\n            if (decodedFrame.headers.get(\"protocol_version\")===\"1\"){\r\n                retVal.accessLevel=decodedFrame.headers.get(\"access_level\");\r\n                retVal.gatewayVersion=decodedFrame.headers.get(\"gateway_version\")\r\n                return retVal;\r\n            }\r\n            else{\r\n                SIProtocolError.raise(\"protocol version 1 not supported by server\");\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"Error\" && decodedFrame.headers.has(\"reason\")){\r\n            let reason:string=\"\"+decodedFrame.headers.get(\"reason\");\r\n            SIProtocolError.raise(reason);\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during authorization\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to receive the number of device available\r\n     */\r\n    protected static encodeEnumerateFrame(){\r\n        return \"ENUMERATE\\n\\n\";\r\n    }\r\n\r\n    /**\r\n     * Decode an enumerate frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodeEnumerateFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            deviceCount:undefined,\r\n        };\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"ENUMERATED\"){\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.deviceCount=decodedFrame.headers.get(\"device_count\");\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during property read\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a describe frame to be send to receive the description of the device(s)\r\n     * @param deviceAccessId Select the accessor\r\n     * @param deviceId Select the device, undefined will give all devices\r\n     * @param propertyId Select the property of the selected device, undefined will give all properties\r\n     * @param flags If present, gives additional information\r\n     */\r\n    protected static encodeDescribeFrame(deviceAccessId?:string, deviceId?:string,\r\n                               propertyId?:number, flags?:SIDescriptionFlags[]):string{\r\n        let frame=\"DESCRIBE\\n\";\r\n        if(deviceAccessId){\r\n            frame+=\"id:\"+deviceAccessId;\r\n            if(deviceId){\r\n                frame+=\".\"+deviceId;\r\n                if(propertyId){\r\n                    frame += \".\"+propertyId;\r\n                }\r\n            }\r\n            frame+=\"\\n\";\r\n        }\r\n        if(flags?.length!==0 && flags!==undefined){\r\n            frame+=\"flags:\";\r\n            flags?.map(flag =>{\r\n                if (flag === SIDescriptionFlags.INCLUDE_ACCESS_INFORMATION) {\r\n                    frame+=\"IncludeAccessInformation,\";\r\n                }\r\n                if (flag === SIDescriptionFlags.INCLUDE_PROPERTY_INFORMATION) {\r\n                    frame+=\"IncludePropertyInformation,\";\r\n                }\r\n                if (flag === SIDescriptionFlags.INCLUDE_DEVICE_INFORMATION) {\r\n                    frame+=\"IncludeDeviceInformation,\";\r\n                }\r\n                if (flag === SIDescriptionFlags.INCLUDE_DRIVER_INFORMATION) {\r\n                    frame+=\"IncludeDriverInformation,\";\r\n                }\r\n            });\r\n            //Suppress the last ',' or \\n if no flag\r\n            frame = frame.substring(0, frame.length - 1);\r\n            frame+=\"\\n\";\r\n        }\r\n        frame+=\"\\n\";\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a description frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodeDescriptionFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            body:undefined,\r\n            status:undefined,\r\n        };\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"DESCRIPTION\" && decodedFrame.headers.has(\"status\")) {\r\n            let status = decodedFrame.headers.get(\"status\");\r\n            retVal.status=status;\r\n            if (status === \"Success\") {\r\n                retVal.body=decodedFrame.body;\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during description\");\r\n        }\r\n        if(decodedFrame.headers.has(\"id\")){\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a read property frame to receive the current value of a property\r\n     * @param propertyId Property to be read\r\n     */\r\n    protected static encodeReadPropertyFrame(propertyId:string):string{\r\n        return \"READ PROPERTY\\nid:\"+propertyId+\"\\n\\n\";\r\n    }\r\n\r\n    /**\r\n     * Decode a property read frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertyReadFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n            value:undefined,\r\n        };\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"PROPERTY READ\" && decodedFrame.headers.has(\"status\")\r\n            && decodedFrame.headers.has(\"id\")) {\r\n            let status = decodedFrame.headers.get(\"status\");\r\n            retVal.status=status;\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n            if(status===\"Success\" && decodedFrame.headers.has(\"value\")){\r\n                retVal.value=decodedFrame.headers.get(\"value\");\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during property read\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a read properties frame to receive the current value of the multiple properties\r\n     * @param propertyIds Properties to be read\r\n     */\r\n    protected static encodeReadPropertiesFrame(propertyIds:string[]):string{\r\n        let frame = \"READ PROPERTIES\\n\\n\";\r\n        frame += JSON.stringify(propertyIds);\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a properties read frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     * */\r\n    protected static decodePropertiesReadFrame(frame:string):SIPropertyReadResult[]{\r\n        let retVal:SIPropertyReadResult[]= [];\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"PROPERTIES READ\" && decodedFrame.headers.has(\"status\")) {\r\n            let jsonBody = JSON.parse(decodedFrame.body);\r\n            let status = decodedFrame.headers.get(\"status\");\r\n            if(status===\"Success\"){\r\n                for(let i=0; i<jsonBody.length;i++){\r\n                    let temp:SIPropertyReadResult={\r\n                        status:SIStatus.ERROR,\r\n                        id:\"\",\r\n                        value:\"\"\r\n                    };\r\n                    temp.status=SIStatusFromString(jsonBody[i].status);\r\n                    temp.id=jsonBody[i].id;\r\n                    temp.value=jsonBody[i].value;\r\n                    retVal.push(temp);\r\n                }\r\n            }\r\n            else{\r\n                SIProtocolError.raise(\"Error on status on read properties frame: \" + status);\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during property read\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a write property frame to write a new parameter for the system\r\n     * @param propertyId Property to be written\r\n     * @param value New value\r\n     * @param flags dDetermine if the new value should be stocked in the database\r\n     */\r\n    protected static encodeWritePropertyFrame(propertyId:string, value?:string, flags?:SIWriteFlags):string{\r\n        let frame = \"WRITE PROPERTY\\nid:\" + propertyId + \"\\n\";\r\n        if(flags){\r\n            frame+=\"flags:\";\r\n            if(flags === SIWriteFlags.PERMANENT){\r\n                frame+=\"Permanent\";\r\n            }\r\n            frame+=\"\\n\";\r\n        }\r\n        if(value){\r\n            frame+=\"value:\"+value+\"\\n\";\r\n        }\r\n        frame+=\"\\n\";\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a property written frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertyWrittenFrame(frame:string):SIInformation {\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"PROPERTY WRITTEN\" && decodedFrame.headers.has(\"status\")\r\n            && decodedFrame.headers.has(\"id\")) {\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error during property write\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to subscribe to a property\r\n     * @param propertyId Property to subscribe\r\n     */\r\n    protected static encodeSubscribePropertyFrame(propertyId:string):string{\r\n        return \"SUBSCRIBE PROPERTY\\nid:\"+propertyId+\"\\n\\n\";\r\n    }\r\n\r\n    /**\r\n     * Decode a property subscribe frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertySubscribedFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"PROPERTY SUBSCRIBED\" && decodedFrame.headers.has(\"status\")\r\n            && decodedFrame.headers.has(\"id\")) {\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error during property subscribe\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to subscribe to multiple properties\r\n     * @param propertyIds Properties to subscribe\r\n     */\r\n    protected static encodeSubscribePropertiesFrame(propertyIds:string[]):string{\r\n        let frame = \"SUBSCRIBE PROPERTIES\\n\\n\";\r\n        frame += JSON.stringify(propertyIds);\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a properties subscribe frame into an array of SISubscriptionResult\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertiesSubscribedFrame(frame:string):SISubscriptionsResult[]{\r\n        let retVal:SISubscriptionsResult[]= [];\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"PROPERTIES SUBSCRIBED\" && decodedFrame.headers.has(\"status\")) {\r\n            let jsonBody = JSON.parse(decodedFrame.body);\r\n            let status = decodedFrame.headers.get(\"status\");\r\n            if(status===\"Success\"){\r\n                for(let i=0; i<jsonBody.length;i++){\r\n                    let temp:SIPropertyReadResult={\r\n                        status:SIStatus.ERROR,\r\n                        id:\"\",\r\n                    };\r\n                    temp.status=SIStatusFromString(jsonBody[i].status);\r\n                    temp.id=jsonBody[i].id;\r\n                    retVal.push(temp);\r\n                }\r\n            }\r\n            else{\r\n                SIProtocolError.raise(\"Error on status on properties subscribed: \" + status);\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during property read\");\r\n        }\r\n        return retVal;\r\n    }\r\n    /**\r\n     * Encode an unsubscribe frame to cancel the subscription to a property\r\n     * @param propertyId Property to unsubscribe\r\n     */\r\n    protected static encodeUnsubscribePropertyFrame(propertyId:string):string{\r\n        return \"UNSUBSCRIBE PROPERTY\\nid:\"+propertyId+\"\\n\\n\";\r\n    }\r\n\r\n    /**\r\n     * Decode an unsubscribe frame into a \"SIInformation\" instance\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertyUnsubscribedFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"PROPERTY UNSUBSCRIBED\" && decodedFrame.headers.has(\"status\")\r\n            && decodedFrame.headers.has(\"id\")) {\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error during property subscribe\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to unsubscribe to multiple properties\r\n     * @param propertyIds Properties to unsubscribe\r\n     */\r\n    protected static encodeUnsubscribePropertiesFrame(propertyIds:string[]):string{\r\n        let frame = \"UNSUBSCRIBE PROPERTIES\\n\\n\";\r\n        frame += JSON.stringify(propertyIds);\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a properties unsubscribe frame into an array of SISubscriptionResult\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertiesUnsubscribedFrame(frame:string):SISubscriptionsResult[]{\r\n        let retVal:SISubscriptionsResult[]= [];\r\n        let decodedFrame:DecodedFrame=this.decodeFrame(frame);\r\n        if(decodedFrame.command===\"PROPERTIES UNSUBSCRIBED\" && decodedFrame.headers.has(\"status\")) {\r\n            let jsonBody = JSON.parse(decodedFrame.body);\r\n            let status = decodedFrame.headers.get(\"status\");\r\n            if(status===\"Success\"){\r\n                for(let i=0; i<jsonBody.length;i++){\r\n                    let temp:SIPropertyReadResult={\r\n                        status:SIStatus.ERROR,\r\n                        id:\"\",\r\n                    };\r\n                    temp.status=SIStatusFromString(jsonBody[i].status);\r\n                    temp.id=jsonBody[i].id;\r\n                    retVal.push(temp);\r\n                }\r\n            }\r\n            else{\r\n                SIProtocolError.raise(\"Error on status on properties unsubscribed frame: \" + status);\r\n            }\r\n        }\r\n        else if(decodedFrame.command===\"ERROR\"){\r\n            SIProtocolError.raise(\"\"+decodedFrame.headers.get(\"reason\"));\r\n        }\r\n        else{\r\n            SIProtocolError.raise(\"unknown error during property read\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Decode a property update frame into a \"SIInformation\" instance, received because we are subscribed to this\r\n     * property\r\n     * @param frame Frame to be decoded\r\n     */\r\n    protected static decodePropertyUpdateFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"PROPERTY UPDATE\" && decodedFrame.headers.has(\"value\")\r\n            && decodedFrame.headers.has(\"id\")) {\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.id=decodedFrame.headers.get(\"id\");\r\n\t\t\tretVal.value=decodedFrame.headers.get(\"value\");\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error receiving property update\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a read datalog frame to be send to get the datalog\r\n     * @param propertyId Wanted property in the format <device access ID>.<device ID>.<property ID>\r\n     * @param dateFrom Start date and time to get logged data from (ISO 8601 extended format)\r\n     * @param dateTo End date and time to get the logged data to (ISO 8601 extended format)\r\n     * @param limit Number of maximum received messages\r\n     */\r\n    protected static encodeReadDatalogFrame(propertyId?:string, dateFrom?:Date, dateTo?:Date, limit?:number){\r\n        let frame:string = 'READ DATALOG\\n';\r\n        if(propertyId){\r\n            frame += \"id:\" + propertyId +\"\\n\";\r\n        }\r\n        frame += SIAbstractGatewayClient.getTimestampHeader('from',dateFrom);\r\n        frame += SIAbstractGatewayClient.getTimestampHeader('to',dateTo);\r\n        if(limit){\r\n            frame += 'limit:'+limit;\r\n        }\r\n        frame += '\\n';\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode a datalog read frame into a \"SIInformation\" instance\r\n     * @param frame frame to be decoded\r\n     */\r\n    protected static decodeDatalogReadFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            status:undefined,\r\n            id:undefined,\r\n            count:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"DATALOG READ\" && decodedFrame.headers.has(\"status\" )\r\n            && decodedFrame.headers.has(\"count\"))\r\n        {\r\n            if(decodedFrame.headers.has(\"id\")) {\r\n                retVal.id = decodedFrame.headers.get(\"id\");\r\n            }\r\n            retVal.status=decodedFrame.headers.get(\"status\");\r\n            retVal.count=decodedFrame.headers.get(\"count\");\r\n            retVal.body=decodedFrame.body;\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error receiving datalog read\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Encode a frame to be send to retrieve all or a subset of stored messages send by devices\r\n     * @param dateFrom start date and time to get logged data from (ISO 8601 extended format)\r\n     * @param dateTo end date and time to get the logged data to (ISO 8601 extended format)\r\n     * @param limit number of maximum received messages\r\n     */\r\n    protected static encodeReadMessagesFrame(dateFrom?:Date, dateTo?:Date, limit?:number){\r\n        let frame:string = 'READ MESSAGES\\n';\r\n        frame += SIAbstractGatewayClient.getTimestampHeader('from',dateFrom);\r\n        frame += SIAbstractGatewayClient.getTimestampHeader('to',dateTo);\r\n        if(limit){\r\n            frame += 'limit:'+limit;\r\n        }\r\n        frame += '\\n';\r\n        return frame;\r\n    }\r\n\r\n    /**\r\n     * Decode the messages read into a \"SIInformation\" instance property\r\n     * @param frame frame to be decoded\r\n     */\r\n    protected static decodeMessagesReadFrame(frame:string):SIInformation[]{\r\n        let retVal:SIInformation[]=[];\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"MESSAGES READ\" && decodedFrame.headers.has(\"status\" )\r\n            && decodedFrame.headers.has(\"count\"))\r\n        {\r\n            let jsonBody=JSON.parse(decodedFrame.body);\r\n            for(let i =0; i<jsonBody.length;i++){\r\n                let message:SIInformation={\r\n                    timestamp: jsonBody.timestamp,\r\n                    accessId: jsonBody.accessId,\r\n                    deviceId: jsonBody.deviceId,\r\n                    messageId: jsonBody.messageId,\r\n                    message: jsonBody.message\r\n                }\r\n                retVal.push(message);\r\n            }\r\n            if(retVal[0]) {\r\n                retVal[0].status = decodedFrame.headers.get(\"status\");\r\n                retVal[0].count = decodedFrame.headers.get(\"count\");\r\n            }\r\n            else{\r\n                let temp:SIInformation={\r\n                    status : decodedFrame.headers.get(\"status\"),\r\n                    count : decodedFrame.headers.get(\"count\")\r\n                }\r\n                retVal.push(temp);\r\n            }\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error receiving messages\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Decode the message of the devices into a \"SIInformation\" instance\r\n     * property\r\n     * @param frame frame to be decoded\r\n     */\r\n    protected static decodeDeviceMessageFrame(frame:string):SIInformation{\r\n        let retVal:SIInformation= {\r\n            id:undefined,\r\n            accessId:undefined,\r\n            messageId:undefined,\r\n            message:undefined,\r\n            timestamp:undefined,\r\n        };\r\n        let decodedFrame: DecodedFrame = this.decodeFrame(frame);\r\n        if (decodedFrame.command === \"DEVICE MESSAGE\" && decodedFrame.headers.has(\"access_id\")\r\n            && decodedFrame.headers.has(\"device_id\")&& decodedFrame.headers.has(\"message_id\")&&\r\n            decodedFrame.headers.has(\"message\") && decodedFrame.headers.has(\"timestamp\"))\r\n        {\r\n            retVal.accessId=decodedFrame.headers.get(\"access_id\");\r\n            retVal.messageId=decodedFrame.headers.get(\"message_id\");\r\n            retVal.message=decodedFrame.headers.get(\"message\");\r\n            retVal.deviceId=decodedFrame.headers.get(\"device_id\");\r\n            retVal.timestamp=decodedFrame.headers.get(\"timestamp\");\r\n        } else if (decodedFrame.command === \"ERROR\") {\r\n            SIProtocolError.raise(\"\" + decodedFrame.headers.get(\"reason\"));\r\n        } else {\r\n            SIProtocolError.raise(\"unknown error receiving device message\");\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    /**\r\n     * Convert a date time to a string for the encode of frames\r\n     * @param key dateFrom (start) or dateTo (stop)\r\n     * @param timestamp Wanted date\r\n     */\r\n    protected static getTimestampHeader(key:string, timestamp?:Date):string{\r\n        if(timestamp){\r\n            return key + ':' + timestamp.toISOString();\r\n        }\r\n        else{\r\n            return '';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the first line (the command of the frame)\r\n     * @param frame Frame to be peeked\r\n     */\r\n    protected static peekFrameCommand(frame:string):string{\r\n        //Return the first line of the received frame\r\n        return (frame.split(\"\\n\"))[0];\r\n    }\r\n}\r\n\r\n/**\r\n * @interface SIGatewayCallback\r\n * Base Interface containing all callback methods that can be called by the SIGatewayClient.\r\n * You can implement this class to your application.\r\n */\r\nexport interface SIGatewayCallback{\r\n\r\n    /**\r\n     * This method is called once the connection to the gateway could be established and\r\n     * the user has been successfully authorized.\r\n     * @param accessLevel Access level that was granted to the user during authorization.\r\n     * @param gatewayVersion Version of the OpenStuder software running on the gateway.\r\n     */\r\n    onConnected(accessLevel:SIAccessLevel, gatewayVersion:string):void;\r\n\r\n    /**\r\n     * Called when the connection to the OpenStuder gateway has\r\n     * been gracefully closed by either side or the connection was lost by any other reason.\r\n     */\r\n    onDisconnected():void;\r\n\r\n    /**\r\n     * Called when the state of the connection changed\r\n     * @param state new state of the connection\r\n     */\r\n    onConnectionStateChanged(state:SIConnectionState):void;\r\n\r\n    /**\r\n     * Called when the enumeration operation started using enumerate() has completed on the gateway.\r\n     * @param status Operation status.\r\n     * @param deviceCount Number of devices present\r\n     */\r\n    onEnumerated(status:SIStatus, deviceCount:number):void;\r\n\r\n    /**\r\n     * Called on severe errors.\r\n     * @param reason Exception that caused the erroneous behavior\r\n     */\r\n    onError(reason:string):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the description requested using the describe() method.\r\n     * @param status Status of the operation.\r\n     * @param description Description object.\r\n     * @param id Subject's ID.\r\n     */\r\n    onDescription(status:SIStatus, description:string, id?:string):void;\r\n\r\n    /**\r\n     * Called when the property read operation started using read_property() has completed on the gateway.\r\n     * @param status Status of the read operation.\r\n     * @param propertyId ID of the property read.\r\n     * @param value The value read.\r\n     */\r\n    onPropertyRead(status:SIStatus, propertyId:string, value?:string):void;\r\n\r\n    /**\r\n     * Called when the multiple properties read operation started using readProperties() has completed on the gateway.\r\n     * @param results List of all results of the operation.\r\n     */\r\n    onPropertiesRead(results:SIPropertyReadResult[]):void;\r\n\r\n    /**\r\n     * Called when the property write operation started using write_property() has completed on the gateway.\r\n     * @param status Status of the write operation.\r\n     * @param propertyId ID of the property written.\r\n     */\r\n    onPropertyWritten(status:SIStatus, propertyId:string):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the status of the property subscription requested\r\n     * using the property_subscribe() method.\r\n     * @param status The status of the subscription.\r\n     * @param propertyId ID of the property.\r\n     */\r\n    onPropertySubscribed(status:SIStatus, propertyId:string):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the status of the properties subscription requested using\r\n     * the subscribeToProperties() method.\r\n     * @param statuses The statuses of the individual subscriptions\r\n     */\r\n    onPropertiesSubscribed(statuses:SISubscriptionsResult[]):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the status of the property unsubscription requested\r\n     * using the property_unsubscribe() method.\r\n     * @param status The status of the unsubscription.\r\n     * @param propertyId ID of the property\r\n     */\r\n    onPropertyUnsubscribed(status:SIStatus, propertyId:string):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the status of the properties unsubscription requested using\r\n     * the unsubscribeFromProperties() method.\r\n     * @param statuses The statuses of the individual subscriptions\r\n     */\r\n    onPropertiesUnsubscribed(statuses:SISubscriptionsResult[]):void;\r\n\r\n    /**\r\n     * This callback is called whenever the gateway send a property update.\r\n     * @param propertyId ID of the updated property.\r\n     * @param value The current value of the property.\r\n     */\r\n    onPropertyUpdated(propertyId:string, value:any):void;\r\n\r\n    /**\r\n     * Called when the datalog property list operation started using read_datalog_properties() has completed on the gateway.\r\n     * @param status Status of the operation.\r\n     * @param properties List of the IDs of the properties for whom data is available in the data log.\r\n     */\r\n    onDatalogPropertiesRead(status:SIStatus,properties:string[]):void;\r\n\r\n    /**\r\n     * Called when the datalog read operation started using read_datalog() has completed on the gateway.\r\n     * @param status Status of the operation.\r\n     * @param propertyId ID of the property.\r\n     * @param count Number of entries.\r\n     * @param values Properties data in CSV format whereas the first column is the date and time in ISO 8601 extended\r\n     * format and the second column contains the actual values.\r\n     */\r\n    onDatalogRead(status:SIStatus, propertyId:string, count:number, values:string):void;\r\n\r\n    /**\r\n     * This callback is called whenever the gateway send a device message indication.\r\n     * @param message The device message received.\r\n     */\r\n    onDeviceMessage(message:SIDeviceMessage):void;\r\n\r\n    /**\r\n     * Called when the gateway returned the status of the read messages operation using the read_messages() method.\r\n     * @param status The status of the operation.\r\n     * @param count Number of messages retrieved.\r\n     * @param messages List of retrieved messages.\r\n     */\r\n    onMessageRead(status:SIStatus, count:number, messages:SIDeviceMessage[]):void;\r\n}\r\n\r\n/**\r\n * @class SIGatewayClient\r\n * Complete, asynchronous (non-blocking) OpenStuder gateway client.\r\n * This client uses an asynchronous model which has the disadvantage to be a bit harder to use than the synchronous\r\n * version. The advantages are that long operations do not block the main thread as all results are reported\r\n * using callbacks, device message indications are supported and subscriptions to property changes are possible.\r\n */\r\nexport class SIGatewayClient extends SIAbstractGatewayClient{\r\n    //Attributes\r\n    private state: SIConnectionState;\r\n    private accessLevel: SIAccessLevel;\r\n    private gatewayVersion: string;\r\n    private ws: WebSocket|null;\r\n\r\n    private user?:string;\r\n    private password?:string;\r\n\r\n    private siGatewayCallback:SIGatewayCallback | undefined;\r\n\r\n    public constructor(){\r\n        super();\r\n        this.state = SIConnectionState.DISCONNECTED;\r\n        this.gatewayVersion='';\r\n        this.accessLevel=SIAccessLevel.NONE;\r\n        this.ws=null;\r\n    }\r\n\r\n    protected ensureInState(state:SIConnectionState){\r\n        if(state!==this.state){\r\n            SIProtocolError.raise(\"invalid client state\");\r\n        }\r\n    }\r\n\r\n    protected setStateSI(state:SIConnectionState){\r\n        this.state=state;\r\n        if(this.siGatewayCallback) {\r\n            this.siGatewayCallback.onConnectionStateChanged(this.state);\r\n        }\r\n    }\r\n\r\n    public setCallback(siGatewayCallback:SIGatewayCallback){\r\n        this.siGatewayCallback=siGatewayCallback;\r\n    }\r\n\r\n    /**\r\n     * Establishes the WebSocket connection to the OpenStuder gateway and executes the user authorization\r\n     * process once the connection has been established in the background. This method returns immediately\r\n     * and does not block the current thread.\r\n     * The status of the connection attempt is reported either by the on_connected() callback on success or\r\n     * the on_error() callback if the connection could not be established or the authorisation for the given\r\n     * user was rejected by the gateway.\r\n     * @param host Hostname or IP address of the OpenStuder gateway to connect to.\r\n     * @param port TCP port used for the connection to the OpenStuder gateway, defaults to 1987\r\n     * @param user Username send to the gateway used for authorization.\r\n     * @param password Password send to the gateway used for authorization.\r\n     */\r\n    public connect(host:string,port:number = 1987,user?:string,password?:string) {\r\n        this.ensureInState(SIConnectionState.DISCONNECTED);\r\n        if(user && password){\r\n            this.user=user;\r\n            this.password=password;\r\n        }\r\n        this.ws = new WebSocket(host + ':' + port);\r\n        this.setStateSI(SIConnectionState.CONNECTING);\r\n        this.ws.onopen = (/*event:Event*/)=>{\r\n            this.setStateSI(SIConnectionState.AUTHORIZING);\r\n            let frame = SIGatewayClient.encodeAuthorizeFrame(user,password);\r\n            if(this.ws){\r\n                this.ws.send(frame);\r\n            }\r\n        };\r\n        this.ws.onmessage = (event:MessageEvent)=>{\r\n            let command: string = SIGatewayClient.peekFrameCommand(event.data);\r\n            let receivedMessage:SIInformation;\r\n            // In AUTHORIZE state, we only handle AUTHORIZED messages\r\n            if(this.state===SIConnectionState.AUTHORIZING && command ===\"AUTHORIZED\"){\r\n                this.setStateSI(SIConnectionState.CONNECTED);\r\n                receivedMessage = SIGatewayClient.decodeAuthorizedFrame(event.data);\r\n                if(receivedMessage.accessLevel) {\r\n                    this.accessLevel = SIAccessLevelFromString(receivedMessage.accessLevel);\r\n                }\r\n                if(receivedMessage.gatewayVersion){\r\n                    this.gatewayVersion=receivedMessage.gatewayVersion;\r\n                }\r\n                if(this.siGatewayCallback && receivedMessage.accessLevel && receivedMessage.gatewayVersion) {\r\n                    this.siGatewayCallback.onConnected(SIAccessLevelFromString(receivedMessage.accessLevel),receivedMessage.gatewayVersion);\r\n                }\r\n            }\r\n            else if(this.state===SIConnectionState.CONNECTED){\r\n                switch (command) {\r\n                    case \"ERROR\":\r\n                        if(this.siGatewayCallback) {\r\n                            this.siGatewayCallback.onError(\"\" + SIGatewayClient.decodeFrame(event.data).headers.get(\"reason\"))\r\n                        }\r\n                        SIProtocolError.raise(\"\"+SIGatewayClient.decodeFrame(event.data).headers.get(\"reason\"));\r\n                        break;\r\n                    case \"ENUMERATED\":\r\n                        receivedMessage = SIGatewayClient.decodeEnumerateFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.deviceCount) {\r\n                            this.siGatewayCallback.onEnumerated(SIStatusFromString(receivedMessage.status),+receivedMessage.deviceCount);\r\n                        }\r\n                        break;\r\n                    case \"DESCRIPTION\":\r\n                        receivedMessage = SIGatewayClient.decodeDescriptionFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.body) {\r\n                            //status: SIStatus, id_: Optional[str], description: object\r\n                            this.siGatewayCallback.onDescription(SIStatusFromString(receivedMessage.status),receivedMessage.body,receivedMessage.id);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTY READ\":\r\n                        receivedMessage = SIGatewayClient.decodePropertyReadFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.id) {\r\n                            this.siGatewayCallback.onPropertyRead(SIStatusFromString(receivedMessage.status),receivedMessage.id,receivedMessage.value);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTIES READ\":\r\n                        let receivedPropertyResult = SIGatewayClient.decodePropertiesReadFrame(event.data);\r\n                        if(this.siGatewayCallback){\r\n                            this.siGatewayCallback.onPropertiesRead(receivedPropertyResult);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTY WRITTEN\":\r\n                        receivedMessage = SIGatewayClient.decodePropertyWrittenFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.id) {\r\n                            //status:SIStatus, propertyId:string\r\n                            this.siGatewayCallback.onPropertyWritten(SIStatusFromString(receivedMessage.status),receivedMessage.id);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTY SUBSCRIBED\":\r\n                        receivedMessage = SIGatewayClient.decodePropertySubscribedFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.id) {\r\n                            this.siGatewayCallback.onPropertySubscribed(SIStatusFromString(receivedMessage.status),receivedMessage.id);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTIES SUBSCRIBED\":\r\n                        let receivedSubscriptionResult:SISubscriptionsResult[]=SIGatewayClient.decodePropertiesSubscribedFrame(event.data);\r\n                        if(this.siGatewayCallback){\r\n                            this.siGatewayCallback.onPropertiesSubscribed(receivedSubscriptionResult);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTY UNSUBSCRIBED\":\r\n                        receivedMessage = SIGatewayClient.decodePropertyUnsubscribedFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.id) {\r\n                            this.siGatewayCallback.onPropertyUnsubscribed(SIStatusFromString(receivedMessage.status),receivedMessage.id);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTIES UNSUBSCRIBED\":\r\n                        let receivedUnsubscriptionResult:SISubscriptionsResult[]=SIGatewayClient.decodePropertiesUnsubscribedFrame(event.data);\r\n                        if(this.siGatewayCallback){\r\n                            this.siGatewayCallback.onPropertiesUnsubscribed(receivedUnsubscriptionResult);\r\n                        }\r\n                        break;\r\n                    case \"PROPERTY UPDATE\":\r\n                        receivedMessage = SIGatewayClient.decodePropertyUpdateFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.id) {\r\n                            this.siGatewayCallback.onPropertyUpdated(receivedMessage.id, receivedMessage.value);\r\n                        }\r\n                        break;\r\n                    case \"DATALOG READ\":\r\n                        receivedMessage = SIGatewayClient.decodeDatalogReadFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.status && receivedMessage.body && receivedMessage.count) {\r\n                            if(receivedMessage.id){\r\n                                this.siGatewayCallback.onDatalogRead(SIStatusFromString(receivedMessage.status),receivedMessage.id, +receivedMessage.count, receivedMessage.body);\r\n                            }\r\n                            else {\r\n                                let properties = receivedMessage.body.split(\"\\n\");\r\n                                this.siGatewayCallback.onDatalogPropertiesRead(SIStatusFromString(receivedMessage.status), properties);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"DEVICE MESSAGE\":\r\n                        receivedMessage = SIGatewayClient.decodeDeviceMessageFrame(event.data);\r\n                        if(this.siGatewayCallback && receivedMessage.timestamp && receivedMessage.accessId && receivedMessage.deviceId\r\n                            && receivedMessage.messageId && receivedMessage.message) {\r\n                            let deviceMessage:SIDeviceMessage={\r\n                                timestamp:receivedMessage.timestamp,\r\n                                accessId:receivedMessage.accessId,\r\n                                deviceId:receivedMessage.deviceId,\r\n                                messageId:receivedMessage.messageId,\r\n                                message:receivedMessage.message\r\n                            }\r\n                            this.siGatewayCallback.onDeviceMessage(deviceMessage);\r\n                        }\r\n                        break;\r\n                    case \"MESSAGES READ\":\r\n                        let receivedMessagesRead:SIInformation[] = SIGatewayClient.decodeMessagesReadFrame(event.data);\r\n                        let deviceMessages:SIDeviceMessage[]=[];\r\n                        let count:number=0;\r\n                        receivedMessagesRead.map(receivedMessageRead =>{\r\n                            if(receivedMessageRead.timestamp && receivedMessageRead.accessId &&\r\n                                receivedMessageRead.deviceId && receivedMessageRead.messageId &&\r\n                                receivedMessageRead.message) {\r\n                                deviceMessages[count] = {\r\n                                    timestamp: receivedMessageRead.timestamp,\r\n                                    accessId: receivedMessageRead.accessId,\r\n                                    deviceId: receivedMessageRead.deviceId,\r\n                                    messageId: receivedMessageRead.messageId,\r\n                                    message: receivedMessageRead.message\r\n                                }\r\n                                count++;\r\n                            }\r\n                        });\r\n                        if(this.siGatewayCallback && receivedMessagesRead[0].status && receivedMessagesRead[0].count) {\r\n                            this.siGatewayCallback.onMessageRead(SIStatusFromString(receivedMessagesRead[0].status),+receivedMessagesRead[0].count\r\n                                , deviceMessages);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        SIProtocolError.raise(\"unsupported frame command :\"+command);\r\n                }\r\n            }\r\n        }\r\n        this.ws.onclose = (/*event:Event*/)=>{\r\n            this.setStateSI(SIConnectionState.DISCONNECTED);\r\n            this.accessLevel = SIAccessLevel.NONE;\r\n        }\r\n        this.ws.onerror = (event:Event)=>{\r\n            SIProtocolError.raise(\"Error occurs on the websocket\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current state of the client. See \"SIConnectionState\" for details.\r\n     * @return Current state of the client\r\n     */\r\n    public getState():SIConnectionState{\r\n        return this.state;\r\n    }\r\n\r\n    /**\r\n     * Return the access level the client has gained on the gateway connected. See \"SIAccessLevel\" for details.\r\n     * @return Access level granted to client\r\n     */\r\n    public getAccessLevel():SIAccessLevel{\r\n        return this.accessLevel;\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the OpenStuder gateway software running on the host the client is connected to.\r\n     * @return Version of the gateway software\r\n     */\r\n    public getGatewayVersion():string{\r\n        return this.gatewayVersion;\r\n    }\r\n\r\n    /**\r\n     * Instructs the gateway to scan every configured and functional device access driver for new devices and remove\r\n     * devices that do not respond anymore.\r\n     * The status of the operation and the number of devices present are reported using the on_enumerated() callback.\r\n     */\r\n    public enumerate(){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeEnumerateFrame());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method can be used to retrieve information about the available devices and their properties from the\r\n     * connected gateway. Using the optional device_access_id, device_id and property_id parameters, the method can\r\n     * either request information about the whole topology, a particular device access instance, a device or a property.\r\n     * The flags control the level of detail in the gateway's response.\r\n     * The description is reported using the on_description() callback.\r\n     * @param deviceAccessId: Device access ID for which the description should be retrieved.\r\n     * @param deviceId Device ID for which the description should be retrieved. Note that\r\n     * device_access_id must be present too.\r\n     * @param propertyId Property ID for which the description should be retrieved. Note that device_access_id and\r\n     * device_id must be present too.\r\n     * @param flags Flags to control level of detail of the response.\r\n     */\r\n    public describe(deviceAccessId?:string, deviceId?:string, propertyId?:number, flags?:SIDescriptionFlags[]){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeDescribeFrame(deviceAccessId,deviceId,propertyId, flags));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is used to retrieve the actual value of a given property from the connected gateway.\r\n     * The property is identified by the property_id parameter.\r\n     * The status of the read operation and the actual value of the property are reported using\r\n     * the on_property_read() callback.\r\n     * @param propertyId The ID of the property to read in the form '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public readProperty(propertyId:string){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeReadPropertyFrame(propertyId));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is used to retrieve the actual value of multiple property at the same time from the connected\r\n     * gateway. The properties are identified by the property_ids parameter.\r\n     * The status of the multiple read operations and the actual value of the property are reported using the\r\n     * onPropertiesRead() callback.\r\n     * @param propertyIds The IDs of the properties to read in the form '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public readProperties(propertyIds:string[]){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws){\r\n            this.ws.send(SIGatewayClient.encodeReadPropertiesFrame(propertyIds));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The write_property method is used to change the actual value of a given property. The property is identified\r\n     * by the property_id parameter and the new value is passed by the optional value parameter.\r\n     * This value parameter is optional as it is possible to write to properties with the data type \"Signal\" where\r\n     * there is no actual value written, the write operation rather triggers an action on the device.\r\n     * The status of the write operation is reported using the on_property_written() callback.\r\n     * @param propertyId The ID of the property to write in the form '{device access ID}.{<device ID}.{<property ID}'.\r\n     * @param value Optional value to write.\r\n     * @param flags Write flags, See SIWriteFlags for details, if not provided the flags are not send by the client\r\n     * and the gateway uses the default flags\r\n     */\r\n    public writeProperty(propertyId:string,value?:any, flags?:SIWriteFlags){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeWritePropertyFrame(propertyId,value,flags));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method can be used to subscribe to a property on the connected gateway. The property is identified by\r\n     * the property_id parameter.\r\n     * The status of the subscribe request is reported using the on_property_subscribed() callback.\r\n     * @param propertyId The ID of the property to subscribe to in the form\r\n     * '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public subscribeToProperty(propertyId:string){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeSubscribePropertyFrame(propertyId));\r\n        }\r\n    }\r\n\r\n    /**\r\n     *This method can be used to subscribe to multiple properties on the connected gateway.\r\n     * The properties are identified by the property_ids parameter. The status of the subscribe request is\r\n     * reported using the on_properties_subscribed() callback\r\n     * @param propertyIds The list of IDs of the properties to subscribe to\r\n     * in the form '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public subscribeToProperties(propertyIds:string[]){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeSubscribePropertiesFrame(propertyIds));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method can be used to unsubscribe from a property on the connected gateway.\r\n     * The property is identified by the property_id parameter.\r\n     * The status of the unsubscribe request is reported using the on_property_unsubscribed() callback.\r\n     * @param propertyId The ID of the property to unsubscribe from in the form\r\n     * '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public unsubscribeFromProperty(propertyId:string){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeUnsubscribePropertyFrame(propertyId));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method can be used to unsubscribe from multiple properties on the connected gateway.\r\n     * The properties are identified by the property_ids parameter. The status of the unsubscribe request is reported\r\n     * using the on_properties_unsubscribed() callback.\r\n     * @param propertyId The list of IDs of the properties to unsubscribe from in the form\r\n     * '{device access ID}.{device ID}.{property ID}'.\r\n     */\r\n    public unsubscribeFromProperties(propertyId:string[]){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeUnsubscribePropertiesFrame(propertyId));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is used to retrieve all or a subset of logged data of a given property from the gateway.\r\n     * The status of this operation and the respective values are reported using the on_datalog_read_csv() callback.\r\n     * @param propertyId Global ID of the property for which the logged data should be retrieved. It has to be in the\r\n     * form '{device access ID}.{device ID}.{property ID}'.\r\n     * @param dateFrom Optional date and time from which the data has to be retrieved, defaults\r\n     * to the oldest value logged.\r\n     * @param dateTo Optional date and time to which the data has to be retrieved, defaults to the current\r\n     * time on the gateway.\r\n     * @param limit Using this optional parameter you can limit the number of results retrieved in total.\r\n     */\r\n    public readDatalog(propertyId:string,dateFrom?:Date,dateTo?:Date,limit?:number){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeReadDatalogFrame(propertyId,dateFrom, dateTo, limit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is used to retrieve the list of IDs of all properties for whom data is logged on the gateway.\r\n     * If a time window is given using from and to, only data in this time windows is considered.\r\n     * The status of the operation is the list of properties for whom logged data is available are reported\r\n     * using the onDatalogPropertiesRead() callback.\r\n     * @param dateFrom Optional date and time of the start of the time window to be considered.\r\n     * @param dateTo Optional date and time of the end of the time window to be considered.\r\n     */\r\n    public readDatalogProperties(dateFrom?:Date,dateTo?:Date){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws){\r\n            this.ws.send(SIGatewayClient.encodeReadDatalogFrame(undefined,dateFrom,dateTo,undefined))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The read_messages method can be used to retrieve all or a subset of stored messages send by devices\r\n     * on all buses in the past from the gateway.\r\n     * The status of this operation and the retrieved messages are reported using the on_messages_read() callback.\r\n     * @param dateFrom Optional date and time from which the messages have to be retrieved, defaults\r\n     * to the oldest message saved.\r\n     * @param dateTo Optional date and time to which the messages have to be retrieved, defaults\r\n     * to the current time on the gateway.\r\n     * @param limit Using this optional parameter you can limit the number of messages retrieved in total.\r\n     */\r\n    public readMessages(dateFrom?:Date, dateTo?:Date, limit?:number){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.send(SIGatewayClient.encodeReadMessagesFrame(dateFrom, dateTo, limit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disconnects the client from the gateway.\r\n     */\r\n    public disconnect(){\r\n        this.ensureInState(SIConnectionState.CONNECTED);\r\n        if(this.ws) {\r\n            this.ws.close();\r\n        }\r\n    }\r\n}\r\n","C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleSimple\\AppSampleSimple.tsx",["68"],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\AppSampleHard.tsx",["69","70","71","72","73","74"],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\Devices.tsx",["75","76","77","78"],"C:\\Users\\Marco\\git\\gateway-client-web\\src\\AppSampleHard\\DeviceMessageRender.tsx",["79","80","81"],"import React from \"react\";\r\nimport {SIDeviceMessage} from \"../OpenStuder/OpenStuder\"\r\nimport Devices, {DeviceProperty} from \"./Devices\";\r\n\r\ntype DMRprops={\r\n    messages:SIDeviceMessage[]\r\n}\r\n\r\nclass DeviceMessagesRender extends React.Component<DMRprops, {}>{\r\n    constructor(props:any) {\r\n        super(props);\r\n    }\r\n\r\n    public renderMessage(message:SIDeviceMessage){\r\n        return(\r\n            <tr>\r\n                <td>\r\n                    {\"\"+message.accessId}\r\n                </td>\r\n                <td>\r\n                    {\"\"+message.deviceId}\r\n                </td>\r\n                <td>\r\n                    {\"\"+message.message}\r\n                </td>\r\n                <td>\r\n                    {\"\"+message.timestamp}\r\n                </td>\r\n            </tr>\r\n        );\r\n    }\r\n\r\n    public render() {\r\n        if(this.props.messages.length>0) {\r\n            return (\r\n                <div>\r\n                    <h2 className=\"content\">\r\n                        Notification Center\r\n                    </h2>\r\n                    <tr>\r\n                        <th scope=\"col\">\r\n                            Source\r\n                        </th>\r\n                        <th scope=\"col\">\r\n                            Device ID\r\n                        </th>\r\n                        <th scope=\"col\">\r\n                            Message\r\n                        </th>\r\n                        <th scope=\"col\">\r\n                            Date\r\n                        </th>\r\n                    </tr>\r\n                    {this.props.messages.map(message => {\r\n                        return this.renderMessage(message);\r\n                    })}\r\n                </div>);\r\n        }\r\n        else{\r\n            return (\r\n                <div>\r\n                    <h2>\r\n                        Notification Center\r\n                    </h2>\r\n                    <p className=\"content\">\r\n                        No messages\r\n                    </p>\r\n                </div>\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport default DeviceMessagesRender;",{"ruleId":"82","replacedBy":"83"},{"ruleId":"84","replacedBy":"85"},{"ruleId":"86","severity":1,"message":"87","line":84,"column":15,"nodeType":"88","messageId":"89","endLine":84,"endColumn":44},{"ruleId":"86","severity":1,"message":"90","line":4,"column":9,"nodeType":"88","messageId":"89","endLine":4,"endColumn":23},{"ruleId":"91","severity":1,"message":"92","line":13,"column":5,"nodeType":"93","messageId":"94","endLine":15,"endColumn":6},{"ruleId":"86","severity":1,"message":"95","line":43,"column":13,"nodeType":"88","messageId":"89","endLine":43,"endColumn":21},{"ruleId":"86","severity":1,"message":"96","line":4,"column":8,"nodeType":"88","messageId":"89","endLine":4,"endColumn":23},{"ruleId":"86","severity":1,"message":"97","line":5,"column":8,"nodeType":"88","messageId":"89","endLine":5,"endColumn":23},{"ruleId":"82","replacedBy":"98"},{"ruleId":"84","replacedBy":"99"},{"ruleId":"100","severity":1,"message":"101","line":348,"column":29,"nodeType":"102","messageId":"103","endLine":348,"endColumn":31},{"ruleId":"100","severity":1,"message":"101","line":1184,"column":70,"nodeType":"102","messageId":"103","endLine":1184,"endColumn":72},{"ruleId":"100","severity":1,"message":"101","line":149,"column":30,"nodeType":"102","messageId":"103","endLine":149,"endColumn":32},{"ruleId":"86","severity":1,"message":"104","line":1,"column":16,"nodeType":"88","messageId":"89","endLine":1,"endColumn":27},{"ruleId":"86","severity":1,"message":"105","line":1,"column":29,"nodeType":"88","messageId":"89","endLine":1,"endColumn":38},{"ruleId":"86","severity":1,"message":"106","line":65,"column":13,"nodeType":"88","messageId":"89","endLine":65,"endColumn":24},{"ruleId":"86","severity":1,"message":"107","line":182,"column":13,"nodeType":"88","messageId":"89","endLine":182,"endColumn":18},{"ruleId":"100","severity":1,"message":"108","line":254,"column":55,"nodeType":"102","messageId":"109","endLine":254,"endColumn":57},{"ruleId":"100","severity":1,"message":"108","line":266,"column":55,"nodeType":"102","messageId":"109","endLine":266,"endColumn":57},{"ruleId":"86","severity":1,"message":"104","line":1,"column":16,"nodeType":"88","messageId":"89","endLine":1,"endColumn":27},{"ruleId":"86","severity":1,"message":"105","line":1,"column":29,"nodeType":"88","messageId":"89","endLine":1,"endColumn":38},{"ruleId":"100","severity":1,"message":"101","line":62,"column":32,"nodeType":"102","messageId":"103","endLine":62,"endColumn":34},{"ruleId":"100","severity":1,"message":"101","line":83,"column":43,"nodeType":"102","messageId":"103","endLine":83,"endColumn":45},{"ruleId":"86","severity":1,"message":"110","line":3,"column":8,"nodeType":"88","messageId":"89","endLine":3,"endColumn":15},{"ruleId":"86","severity":1,"message":"90","line":3,"column":18,"nodeType":"88","messageId":"89","endLine":3,"endColumn":32},{"ruleId":"91","severity":1,"message":"92","line":10,"column":5,"nodeType":"93","messageId":"94","endLine":12,"endColumn":6},"no-native-reassign",["111"],"no-negated-in-lhs",["112"],"@typescript-eslint/no-unused-vars","'responseSubscription' is assigned a value but never used.","Identifier","unusedVar","'DeviceProperty' is defined but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'btnLabel' is assigned a value but never used.","'AppSampleMedium' is defined but never used.","'AppSampleSimple' is defined but never used.",["111"],["112"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'ChangeEvent' is defined but never used.","'FormEvent' is defined but never used.","'newProperty' is assigned a value but never used.","'count' is assigned a value but never used.","Array.prototype.map() expects a value to be returned at the end of arrow function.","expectedAtEnd","'Devices' is defined but never used.","no-global-assign","no-unsafe-negation"]